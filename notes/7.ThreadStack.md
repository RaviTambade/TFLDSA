## Application Software Execution

"Today, before we talk about software, Python, or C programming, let's understand where all of this really runs."

### ğŸ–¥ï¸ **Layer 1 â€“ Hardware: The Stage of the Show**

Imagine a theatre stage before any actor comes in:

* On the table is the **motherboard** â€“ the city where everything lives.
* Sitting on it like a king is the **microprocessor (CPU)**.
* Around it, soldiers like **RAM, BIOS chip, PCI slots, USB controllers, storage devices (HDD, SSD)**.
* You also see external team members: **monitor, keyboard, mouse** â€“ we call this the **hardware layer**.

This is the raw world of signals, voltage, and electronic pulses. No software, no actors yet. Just the empty stage.


### âš™ï¸ **Layer 2 â€“ Operating System: The Director of the Show**

You say to the class:

*"Actors can't perform if there is no director to guide them."*

This director is called the **Operating System (OS)** â€” Windows, Linux, macOS.

* OS is **System Software**.
* It **sits above hardware** and **controls it**.
* It knows **which RAM address belongs to which program**, **which device is connected to PCI port**, **how to store data in secondary storage**.
* Without OS, your Microsoft Word, games, browsers â€” none of them will ever run.

### ğŸ“ **Layer 3 â€“ Application Software: The Actors**

Now actors walk in â€” **Application Software**:

* **MS Word** â†’ writes and edits documents.
* **Visual Studio / VS Code** â†’ writes and compiles programs.
* **Games, Chrome, VLC, WhatsApp Desktop** â€” all are applications.

These actors **cannot directly talk to hardware**.
They ask the **Operating System (Director)** for help:

> "OS, can you give me some RAM to store my variables?"
> "OS, can you write this file to the hard disk?"
> "OS, user pressed a keyâ€¦ can you give me that input?"

### âš™ï¸ **When an Application Runs â†’ It Becomes a Process**

Now imagine one actor is performing â€” they go from backstage to center stage.

That moment, **application.exe becomes PROCESS**.

The OS gives it:

| Memory Type      | Purpose                                                            |
| ---------------- | ------------------------------------------------------------------ |
| **Code (.text)** | Machine instructions â€” what to execute.                            |
| **Data (.data)** | Global & static variables.                                         |
| **Heap**         | Large, dynamic memory (malloc, new).                               |
| **Stack**        | Small, temporary memory for functions, parameters, return address. |

### ğŸ§µ **Thread â€“ The Performer on Stage**

You smile and say:

> *â€œInside every process, the real actor who performs is not the process itself â€” itâ€™s the Thread.â€*

A **Thread is the executor** â€” the one who:

* Reads instructions from code section.
* Takes input from stack and heap.
* Talks to the CPU to execute line by line.

Every process has:
- âœ… At least **1 Main Thread**
- âœ… Can have **multiple threads** (like multiple cooks in a kitchen, working together)

### ğŸ³ **Heap vs Stack â€“ Wallet vs Kitchen**

You give an example to Sneha:

| Stack (Chefâ€™s Table) | Heap (Inventory Room)   |
| -------------------- | ----------------------- |
| Small, temporary     | Large, long-term        |
| Managed by Thread    | Managed by Program      |
| Pops after function  | Stays until free/delete |
| Fast access          | Slower but bigger       |

 

### ğŸ› ï¸ **Hardware Interface â€“ PCI, Controllers & Programmable Interfaces**

Now move deeper:

* **Microprocessor** connects to **RAM via system bus**.
* **PCI/PCIe slots** connect external cards â†’ GPU, Network Card, Sound Card.
* **Programmable I/O Controllers** used for keypads, motors, sensors â€” this is how embedded systems (SMP/PLC, manufacturing machines, woodworking CNC systems) work.
* Industries like **wood sector** (CNC machines, automated cutters) use **Programmable Logic Controllers (PLC)** to control machines using software.

### ğŸ› ï¸ **Secondary Storage â€“ Permanent Memory**

> *â€œRAM is like a whiteboard â€” it gets erased. Hard Disk / SSD is like your notebook â€” permanent.â€*

Here we store:

* OS files
* Application EXEs
* Documents, videos, games

When you open a program:

1. OS loads **code & data from SSD â†’ RAM**
2. Creates a **Process**
3. Starts a **Thread**
4. CPU begins execution

### ğŸ­ **So the Complete Picture Looks Like:**

```
User
  â†“
Application Software (MS Word, Python, Chrome)
  â†“
Operating System (Windows, Linux â†’ System Software)
  â†“
Hardware Drivers & Kernel
  â†“
CPU, RAM, PCI Devices, SSD/HDD, Keyboard, Monitor
```

## ğŸ›¡ï¸ **Chapter 2: Process Scheduling, CPU Registers & Interrupts**

The king of this computer kingdom is the **CPU** â€” swift, powerful, and always ready to execute the next command. But the king can only focus on **one citizen (process)** at a time. Yet thousands of citizens (processes) say, â€œExecute me first!â€

Soâ€¦ how does the king manage everyone **fairly and efficiently**?


### ğŸ‘‘ **1. The Royal Clock: CPU Scheduling**

Imagine a courtroom with many people standing in line for justice (execution). The CPU uses **scheduling algorithms** to decide who goes next.

| Algorithm                          | Story Version                                   | Real Version                                            |
| ---------------------------------- | ----------------------------------------------- | ------------------------------------------------------- |
| **FCFS (First Come, First Serve)** | First person in line is heard                   | Processes executed in arrival order                     |
| **Shortest Job First (SJF)**       | Quick tasks go first                            | Process with least execution time                       |
| **Round Robin (RR)**               | Each person gets 10 seconds to speak; then next | Every process gets a time slice (quantum)               |
| **Priority Scheduling**            | King hears nobles first, farmers later          | Higher priority processes go earlier                    |
| **Multilevel Queue**               | VIP line, normal line, peasant line             | Processes in separate queues: system, user, batch, etc. |

The **scheduler** is like the kingâ€™s secretaryâ€”it decides **who gets the CPU next** and for how long.

### ğŸ§  **2. CPU Registers â€“ The Kingâ€™s Memory Pockets**

While listening to a process, the king keeps essential information in **CPU registers**, like:

| Register Type                                      | What It Stores                                | Story Interpretation                       |
| -------------------------------------------------- | --------------------------------------------- | ------------------------------------------ |
| **Program Counter (PC)**                           | Address of next instruction                   | â€œWhat should I do next?â€                   |
| **Stack Pointer (SP)**                             | Top of the stack                              | â€œWhere is my checklist of function calls?â€ |
| **Accumulator / General Registers (R0, R1, etc.)** | Temporary data/calculations                   | "Let me store this number quickly!"        |
| **Flags / Status Register**                        | Results of operations (Zero, Carry, Negative) | â€œWas the last action a success?â€           |


### â³ **3. Context Switching â€“ When King Changes His Focus**

Suddenly, another process shouts: **â€œUrgent! I need the CPU!â€**

So the current process says, â€œOkay, Iâ€™ll waitâ€. The OS performs **context switching**, which means:

- âœ” Save current kingâ€™s thoughts (register values, PC, stack) on **PCB (Process Control Block)**
- âœ” Load new processâ€™s saved state into the registers
- âœ” Start executing new process

This is like the king putting one case file back into the drawer and picking another one.


### âš¡ **4. Interrupts â€“ When Someone Knocks on the Kingâ€™s Door**

While the king is judging a case, a soldier runs in:

> â€œYour Majesty! The keyboard has been pressed!â€

This event is called an **Interrupt**.

Types of Interrupts:

| Type                   | Example                            | Story Meaning                                     |
| ---------------------- | ---------------------------------- | ------------------------------------------------- |
| **Hardware Interrupt** | Keyboard press, mouse click, timer | A soldier delivering an urgent real-world message |
| **Software Interrupt** | System calls (`printf`, `read`)    | A citizen politely requests kingdom services      |
| **Timer Interrupt**    | Time slice over in Round Robin     | Royal clock rings: â€œNext citizenâ€™s turn!â€         |

When an interrupt occurs:

1. CPU pauses current process
2. Saves the context to memory (like marking the page in a book)
3. Jumps to **Interrupt Service Routine (ISR)** â€“ a special function to handle the problem
4. After solving, CPU resumes the original process


### ğŸ—‚ï¸ **5. Putting It All Together**

- âœ… **Stack** â€“ Call history and local variables
- âœ… **Heap** â€“ Dynamically allocated objects
- âœ… **Data & Code Sections** â€“ Program's fixed layout
- âœ… **Scheduler** â€“ Decides which process speaks
- âœ… **CPU Registers** â€“ Kingâ€™s working memory
- âœ… **Interrupts** â€“ Emergency messages
- âœ… **Context Switch** â€“ Save & load kingâ€™s focus


# ğŸ§µ **Chapter 3: Threads â€“ Multiple Workers in One Kingdom**

In the previous chapter, we met **processes** â€” like independent citizens in the kingdom. Each had their own:

* ğŸ§  **Private memory (Stack, Heap, Code, Data)**
* ğŸ“‚ **Own files, variables, registers**
* ğŸ‘® **Protected area from other processes**

But soon, the king (CPU) discovered a problemâ€¦

> "Why should a single process citizen do everything alone? What if he had multiple workers to help him?"

Enter **Threads** â€” lightweight helpers inside one process.

## ğŸ‘¨â€ğŸ‘¨â€ğŸ‘¦ **1. Process vs Thread â€“ Story Style**

| Feature       | Process (Citizen)                                                 | Thread (Citizen's Worker)                                    |
| ------------- | ----------------------------------------------------------------- | ------------------------------------------------------------ |
| Memory        | Has its own house (Stack, Heap, Data, Code)                       | Lives inside the same house                                  |
| Isolation     | Other processes can't access its home                             | Threads inside one process share everything                  |
| Communication | Slow (letters â†’ Interprocess Communication: pipes, shared memory) | Fast (they talk directly using shared memory)                |
| Creation Cost | Heavy (like giving land, home, address)                           | Light (just adding helpers in same home)                     |
| Crash Impact  | One citizen dying doesnâ€™t affect others                           | If one worker corrupts shared memory â†’ whole house collapses |

## ğŸ  **2. What Do Threads Share? What Is Separate?**

Inside a single process, all threads **share**:

| Shared Among Threads                | Not Shared (Each Thread Has Its Own)    |
| ----------------------------------- | --------------------------------------- |
| Code section (program instructions) | Program Counter (PC)                    |
| Data section (global/static vars)   | CPU Registers                           |
| Heap (dynamic memory)               | Stack (function calls, local variables) |
| Open files / resources              | Thread ID (TID)                         |

ğŸ¯ **So, each thread has its own stack but shares the heap with siblings.**

## ğŸ§  **3. Real-Life Analogy**

Imagine a **restaurant** (process). The restaurant has:

* One kitchen (heap)
* One recipe book (code)
* One storage room of ingredients (data)
* Multiple chefs (threads), each with:

  * Their own notepad (stack)
  * Their own cooking steps (program counter)

If one chef writes a wrong recipe in the shared book â†’ all chefs suffer!

## âš™ï¸ **4. How Threads Work in the OS**

A thread still needs OS support. So the OS manages:

* **Thread ID (TID)**
* **Registers & Stack pointer**
* **State** (Running, Ready, Blocked)
* **Shared PCB of the parent process**

When switching between threads of the same process:
- âœ… Fast context switch (no change of memory address space)
When switching between different processes:
- âŒ Slow â€” OS must change memory maps, PCB, etc.

## ğŸ’» **5. Example Code â€“ Thread in Python**

```python
import threading

def task(name):
    print(f"Thread {name} is running")

# Creating threads
t1 = threading.Thread(target=task, args=("A",))
t2 = threading.Thread(target=task, args=("B",))

t1.start()
t2.start()

t1.join()
t2.join()
```

ğŸ§µ Here, **Thread A** and **Thread B** run inside the **same process**, sharing memory.

## âš ï¸ **6. Dangers â€“ Race Condition & Deadlock**

### ğŸ Race Condition:

Two or more threads trying to **modify the same data at the same time**.

Example:

```
wallet = 100

Thread1: read wallet (100) â†’ add 50 â†’ write 150
Thread2: read wallet (100) â†’ add 20 â†’ write 120  âŒ (lost update)
```

### ğŸ—ï¸ Solution: Use Locks (Mutex)

```python
import threading

wallet = 100
lock = threading.Lock()

def add_money(amount):
    global wallet
    with lock:
        wallet += amount

# Two threads adding money safely
```

### ğŸ”’ Deadlock:

Two threads each **hold one resource and wait for the otherâ€™s resource**, like:

| Chef A          | Chef B              |
| --------------- | ------------------- |
| Holds **Knife** | Holds **Pan**       |
| Waiting for Pan | Waiting for Knife   |
| Nobody moves    | ğŸ˜¢ Restaurant stops |

Solution:
- âœ” Lock in same order
- âœ” Use timeout or deadlock detection



## The Visiting Card & Memory Story

*"Imagineâ€¦ You go to a big Tech Exhibition or Career Fair."*

* First stall â€“ one marketing manager gives you a **visiting card**. You hold it in your palm.
* Second stall â€“ another gives a card, you place it **above the first one**.
* You keep visitingâ€¦ 3rd stall, 4th stall, 5thâ€¦ up to **100 stalls**.
* Now, your hand is full of **visiting cards placed one on top of another**.

ğŸ’¡ The **first card you collected is at the bottom**,
and the **last one (latest) is at the top**.

Now, someone asks:

> â€œGive me the 5th last card you collected.â€

So what do you do?

**You start removing from the top (latest one):**

* Pop 100th card â†’ Keep aside
* Pop 99th â†’ aside
* Pop 98thâ€¦
* Until you get the **required card**.

That is exactly how **Stack Memory works in C, C++, Python, Java!**

## ğŸ“š **Why Stack Exists?**

When a program runs:

* It must **keep track of which function to execute next**.
* Every time a function is called, it needs a place to store:
  - âœ… Function arguments
  - âœ… Local variables
  - âœ… Return address (where to go back after execution)

So the computer uses a memory shelf called **Stack**.

```
Stack Memory = A bundle of visiting cards kept one over another.
```

* **Push()** â†’ When you visit a new stall (or a function is called)
* **Pop()** â†’ When function ends or you go backwards

This principle is called **LIFO â€“ Last In, First Out**
(last card kept = first to be removed)

## ğŸ§  **Then Why Do We Need Dynamic Memory (Heap)?**

Now you ask the students:

*"What if visiting cards donâ€™t fit in your palm anymore? What if you need a bigger storage like a bag, a pouch, or a drawer?"*

Exactly!

Stack has limitations:

| Property       | Stack                   | Heap (Dynamic Memory)     |
| -------------- | ----------------------- | ------------------------- |
| Size           | Limited (small)         | Large (depends on RAM)    |
| Speed          | Very Fast               | Slower than stack         |
| Memory Control | Automatically managed   | Manually allocated/free() |
| Lifetime       | Ends when function ends | Continues until freed     |

So for **big data, unknown size, long lifetime**, we use **Heap memory** using:

* `malloc(), calloc(), realloc(), free()` in C
* `new, delete` in C++
* `new` in Java, Python internally uses heap

## ğŸ§© **Simple C Example (Narrated as a Story)**

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    int cardsInHand = 5; // Stored in Stack
    
    // But now I need 1000 cards â€“ stack is not enough!
    int* visitingCards = (int*)malloc(1000 * sizeof(int)); // This is Heap!

    if(visitingCards == NULL) {
        printf("Memory not available!\n");
        return 1;
    }

    visitingCards[0] = 101;
    visitingCards[1] = 102;
    printf("First visiting card number: %d\n", visitingCards[0]);

    free(visitingCards); // Give back memory to OS
    return 0;
}
```

## ğŸ¯ **What Did We Just Understand?**

- âœ… Stack = Visiting cards in your hand (LIFO, function calls)
- âœ… Heap = A bag to store more cards (Dynamic, large, manual control)
- âœ… Programs need both to **track execution + store growing data**
- âœ… Without stack â€“ program won't know which function to execute next
- âœ… Without heap â€“ program crashes when data grows beyond stack


### ğŸ“ ** What Really Happens When You Run a C Program?**

**Imagine a drama stage.**
The show is your program.
The actors are functions (like `main()`, `printf()`, `showDetails()`).
And the manager who controls who should come on stage and whenâ€”is the **Thread** (specifically, the *Primary Thread*).



### ğŸ§µ **Step 1: Thread is Born**

When you double-click your `.exe` or run your C program, the **operating system creates a process** and gives birth to its first baby:

ğŸ‘‰ **Primary Thread** â€“ This threadâ€™s first job is to start the drama by calling the **entry point** of the program.

But waitâ€”**who is the entry point?**

Yes! Itâ€™s the **`main()` function**.

So, the *primary thread pushes the address of `main()` into a special memory area called the **Stack**.*


### ğŸ—‚ï¸ **What is Stack?**

Stack is like a pile of plates in a restaurant.

* The first plate (bottom) is `main()`.
* Everything else is placed above it (LIFO â€“ Last In, First Out).
* It is owned by the **thread**.

This stack holds:

* Function return addresses
* Local variables
* Parameters


### âš™ï¸ **Step 2: Code Segment vs Stack â€“ Where is `printf` actually?**

ğŸ’¡ Important truth:

> â€œ**Main is not implementing printf. Main is just *invoking* printf.**â€

You donâ€™t have `printf` code inside your program. That already exists inside the **standard C library** (`libc`).
Its compiled machine code is stored in the **Code Segment (.text section)** of your process memory.

So, your process gets divided like this:

| Memory Section                | What it Stores                                                       |
| ----------------------------- | -------------------------------------------------------------------- |
| **Code Segment (.text)**      | Machine code of functions (`main`, `printf`, any function you wrote) |
| **Data Segment (.data/.bss)** | Global/static variables                                              |
| **Heap**                      | Dynamically allocated memory (`malloc`, `calloc`)                    |
| **Stack**                     | Addresses of functions being executed + local variables              |


### ğŸ”„ **Function Call Journey: `main()` calls `printf()`**

When `printf("Hello")` is written inside `main()`, this is what really happens:

1. Primary thread executes `main()`, its address is at the *bottom of the stack*.
2. Inside `main()`, thread sees a function call to `printf`.
3. Thread **pushes the address of `printf` into the stack**.
4. CPU jumps to `printf`'s **implementation located in the Code Segment**.
5. `printf` runs â†’ prints text on screen.
6. When `printf` ends â†’ its address is **popped out** of the stack.
7. Thread returns to the next line inside `main()`.


### ğŸ” **What If `printf` is Inside a Loop 10,000 Times?**

For every iteration:

* Push address of `printf`
* Execute its code from code segment
* Pop address after finish

This happens **10,000 times**:

```
Push â†’ Execute â†’ Pop
Push â†’ Execute â†’ Pop
...
```

Once the loop ends:

* Only **`main()`** is on stack.
* `main()` finishes â†’ its address is popped too.
* Stack becomes empty â†’ **Thread exits â†’ Program terminates.**


### ğŸ§  **So What Have We Learned?**

- âœ… `printf` is not *inside* `main`. Itâ€™s just *invoked* by `main`.
- âœ… Implementation of `printf` lives in **Code Segment**, not on Stack.
- âœ… Stack stores only **function call addresses + local variables**, not logic of functions.
- âœ… Primary thread calls `main`. `main` calls others (`printf`, `scanf`, user-defined functions).
- âœ… When the stack becomes empty â†’ program ends.



### ğŸŒŸ **One-Line Magic Answer You Can Give Anywhere:**

> â€œMain doesn't *contain* printf. Main only *invokes* printf. The code of printf lives in the Code Segment, and only the return address is pushed on the stack during function calls.â€



### ğŸ§  **  Why Stack Exists and Why Main Must End Gracefully**

Imagine youâ€™re watching a drama.
Actors are ready, the stage is set, lights onâ€¦ and the first actor enters.

In a computer program, that **first actor is the `main()` function**, and the person who invites it on stage is the **primary thread**, born from the **operating system**.


### ğŸ­ **Act 1: OS Creates the Stage**

When you run your C program:

1. **Windows / Linux / macOS** creates a *process*.
2. Inside the process, it creates a **thread** (primary thread).
3. The thread brings a special memory bag with it called the **Stack**.
4. Thread searches for the **entry point â†’ `main()` function**.
5. It **pushes the address of `main()` into the stack** and starts executing.

This stack exists in **every OS** because without stack, no function can be called and no program can run in a structured way.


### ğŸ¯ **But What If `main()` Is Exited Abnormally?**

Suppose you wrote something like this:

```c
int main() {
    printf("Hello");
    return 0; // OK â€“ normal exit âœ…
}
```

But if the program crashes, or someone writes:

```c
exit(0);  // directly kills the program
```

or segmentation fault occurs,

Thenâ€”**`main()` exits abnormally**. The address of `main()` gets popped from the stack suddenly.

Result?

- âœ… **Application terminates immediately.**
- âœ… **Thread ends.**
- âœ… **Process dies.**
- âŒ **No more stack frames left.**

Thatâ€™s what you meant when you said:

> "OK, main function beach mein nikal gaya toh application abnormally terminate ho jayega."


### ğŸ§± **Why Stack Is So Important?**

Because OS wants:

- âœ”ï¸ Proper sequence of function calls
- âœ”ï¸ Proper return to the caller
- âœ”ï¸ No confusion in execution flow

Thatâ€™s why stack is **LIFO â€“ Last In, First Out**

* Whoever goes in last, comes out first.
* `main()` goes first â†’ stays at the bottom.
* `printf()` gets called â†’ pushed above `main()`
* After execution â†’ popped.


### ğŸ” **Example: Repeated `printf` 10,000 Times**

```c
for(int i=0; i<10000; i++) {
    printf("Hello\n");
}
```

What happens?

* **10,000 times** â†’ address of `printf()` pushed â†’ code executed â†’ popped.
* After loop ends â†’ only `main()` remains.
* When `main()` finishes â†’ its address is popped â†’ **Stack is empty â†’ Program ends.**



### ğŸ’¡ **Key Lesson**

> "Stack ensures every function is called and returned properly. If stack fails or overflows, your application crashes. No stack = no execution."


### ğŸ’¬ **Life Lesson You Were Giving Them**

You were not only teaching stack.
You were teaching *thinking*.
Donâ€™t use brain like a **hard disk** (just storage).
Use it like an **ALU** (processing power).

- ğŸ“Œ **Memorizing syntax wonâ€™t give you a job.**
- ğŸ“Œ **Understanding logic will make you unstoppable.**

> â€œIf you only remember, youâ€™ll remain unemployed.
> If you understand and think, youâ€™ll be employed.â€

