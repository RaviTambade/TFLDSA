# â­ ** File I/O + Serialization in Java**

## ðŸ§‘â€ðŸ« **Scene: Mentor Ravi and Student Prajwal in the Transflower Coding Lab**

Prajwal has just created his own custom `LinkedList` class. He proudly adds nodes, deletes nodes, and prints them. Suddenly he asks:

**â€œSir, every time I rerun the program, my LinkedList becomes empty. Can I save it somewhereâ€¦ like how games save progress?â€**

Ravi smiles.

## ðŸŽ¯ **Mentor:**

â€œPrajwal, you just discovered the real reason why File I/O exists.
Java programs live in RAM. RAM is like a whiteboard â€” if the power goes off, everything is wiped.

So we need something permanent:
ðŸ“ **Files** â†’ Hard disk â†’ Data stays even after the app closes.

And today, Iâ€™ll give you a small magical tool â€” a *time machine* that freezes your LinkedList and restores it later.â€

# ðŸª„ **Serialization = Freezing Your Object**

Mentor explains:

â€œImagine your LinkedList is a character in a video game. If you want to â€˜save the gameâ€™, you freeze the entire object along with its internal state â€” nodes, values, size, everything.

Java gives this superpower through:

### âœ” `ObjectOutputStream` â†’ freezes (serializes)

### âœ” `ObjectInputStream` â†’ unfreezes (deserializes)

But there is one rule:

### ðŸ‘‰ Your LinkedList class must implement `Serializable`.â€


# ðŸ— **Your FileIOManager â€” Explained Like a Story**

### ## ðŸ’¾ **serialize() â€” Saving the LinkedList to File**

```java
public void serialize(LinkedList list, String filename) {
    try {
        FileOutputStream fout = new FileOutputStream(filename);
        ObjectOutputStream ostream = new ObjectOutputStream(fout);
        ostream.writeObject(list);
        ostream.close();
        fout.close();
        System.out.println("List save to file");
    } catch (Exception e) {
        System.out.println(e);
    }
}
```

### ðŸ§‘â€ðŸ« Mentor Explains:

â€œThink of this process like packing your LinkedList inside a box:

1. `FileOutputStream` â†’ Opens a file (creates one if not present).
2. `ObjectOutputStream` â†’ Converts your LinkedList object into a stream of bytes.
3. `writeObject(list)` â†’ Packs the entire LinkedList into the file.
4. Close the streams â†’ Seal the box.

Now your LinkedList lives forever on disk.â€

## ðŸ“¥ **deserialize() â€” Bringing the LinkedList Back to Life**

```java
public LinkedList deserialize(String filename) {
    LinkedList list=new LinkedList();
    try {
        FileInputStream fout = new FileInputStream(filename);
        ObjectInputStream ostream = new ObjectInputStream(fout);
        list = (LinkedList) ostream.readObject();
        ostream.close();
        fout.close();
        System.out.println("List read from file");
    } catch (Exception e) {
        System.out.println(e);
    }
    return list;
}
```

### ðŸ§‘â€ðŸ« Mentorâ€™s Story:

â€œNow imagine the next day Prajwal comes back and says:

**â€˜Sir, I want my LinkedList exactly the way I saved it.â€™**

Serialization makes that happen:

1. `FileInputStream` â†’ Opens your stored box.
2. `ObjectInputStream` â†’ Reads byte-by-byte and reconstructs the entire LinkedList structure.
3. `readObject()` â†’ Brings the original LinkedList back alive.â€


# ðŸŽ¨ **Mentor Example: Real Flow**

```
LinkedList list = new LinkedList();
list.add(10);
list.add(20);
list.add(30);

// Save list
FileIOManager io = new FileIOManager();
io.serialize(list, "list.dat");

// Load list again
LinkedList newList = io.deserialize("list.dat");
newList.display();
```

### Output:

```
List save to file
List read from file
10 -> 20 -> 30 -> null
```

Prajwal claps.
His LinkedList time machine works.


# ðŸ§© **Important Notes (Mentor Tips)**

### âœ” Your LinkedList class must implement:

```java
class LinkedList implements Serializable
```

### âœ” Every Node inside LinkedList must also implement:

```java
class Node implements Serializable
```

### âœ” Serialization stores the complete structure

â€” No need to write each node manually.

### âœ” File extension doesnâ€™t matter

`.dat`, `.bin`, `.obj`, `.ser` â†’ all valid.

