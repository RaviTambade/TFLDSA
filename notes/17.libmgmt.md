 # **Problem Statement: Bookshelf Stack Implementation (LIFO Simulation)**

A Transflower library wants to organize books using a **stack-based bookshelf**, where the **last book placed on the shelf should be the first one removed**. This follows the **LIFO (Last-In First-Out)** principle, just like a memory stack in computers.

You are required to implement a simple bookshelf system with the following specifications:

### **Requirements**

1. **Create a `Book` class**

   * Data members:

     * `title` (string)
     * `author` (string)
   * Provide:

     * A **default constructor** that initializes the book with:

       * Title: `"Rich Dad Poor Dad"`
       * Author: `"Robert K"`
     * A **parameterized constructor** to set custom title and author values.

2. **Create a `Shelf` class that behaves like a Stack**

   * Use a **fixed-size array** of 5 `Book` objects.
   * Maintain an integer `top` to store the index of the topmost book.
   * Initialize `top` as `-1` in the constructor.
   * Implement the following operation:

     * `push(Book)`

       * Add a book to the top of the shelf.
       * (Overflow check not implemented initially.)

3. **In the `main()` function**

   * Create a `Shelf` object named `motivationalShelf`.
   * Create multiple book objects using the parameterized constructor.
   * Push these books onto the shelf one by one.
   * Intentionally push **more than 5 books** to simulate **stack overflow** and observe the behavior.

### **Output / Objective**

* Understand how a **stack works using a real-life analogy** (books on a shelf).
* Visualize **LIFO behavior** in object-oriented design.
* Observe what happens when the system **pushes beyond the fixed capacity** (logical overflow scenario).
* Extend the system later to include:

  * Overflow check
  * Underflow check
  * `pop()` operation
  * `peek()` operation
  * Display all books
 


Below is the **complete extended C++ solution** based on your given code, now including:

- ‚úî Overflow check
- ‚úî Underflow check
- ‚úî `push()`
- ‚úî `pop()`
- ‚úî `peek()`
- ‚úî `display()`

I have kept the structure identical to your earlier code, just extended it.

 

# ‚úÖ **Complete Stack Implementation (Bookshelf Example)**

```cpp
// LIFO: Last in First out ---- stack
// FIFO: First in First out ---- queue
#define size 5
#include <iostream>
#include <string.h>

using namespace std;

class Book {
public:
    string title;
    string author;

    Book() {
        this->title = "Rich Dad Poor Dad";
        this->author = "Robert K";
    }

    Book(string t, string a) {
        this->title = t;
        this->author = a;
    }

    void printBook() const {
        cout << "Title: " << title << ", Author: " << author << endl;
    }
};

class Shelf {
private:
    int top; // index of the top book
    Book books[size];

public:
    Shelf() {
        this->top = -1;
    }

    // PUSH operation with overflow check
    void push(Book theBook) {
        if (top == size - 1) {
            cout << "‚ùå Overflow! Cannot add more books. Shelf is FULL.\n";
            return;
        }
        top++;
        books[top] = theBook;
        cout << "üìò Pushed: " << theBook.title << endl;
    }

    // POP operation with underflow check
    Book pop() {
        if (top == -1) {
            cout << "‚ùå Underflow! No books to remove.\n";
            return Book("EMPTY", "NONE");
        }
        Book removedBook = books[top];
        cout << "üìï Popped: " << removedBook.title << endl;
        top--;
        return removedBook;
    }

    // PEEK (top book)
    Book peek() {
        if (top == -1) {
            cout << "‚ùå Shelf is EMPTY. Nothing to peek.\n";
            return Book("EMPTY", "NONE");
        }
        cout << "üëÄ Top Book: " << books[top].title << endl;
        return books[top];
    }

    // DISPLAY all books
    void display() {
        if (top == -1) {
            cout << "üì≠ Shelf is EMPTY.\n";
            return;
        }

        cout << "\nüìö Books on Shelf (Top to Bottom):\n";
        for (int i = top; i >= 0; i--) {
            cout << i << ". ";
            books[i].printBook();
        }
        cout << endl;
    }
};

int main() {

    Shelf motivationalShelf;

    Book book1("You can win", "Shiv Khera");
    Book book2("Ignited Minds", "APJ Kalam");
    Book book3("The Monk who sold his Ferrari", "Robin Sharma");
    Book book4("Mahabharat", "Vyas");
    Book book5("Ramayan", "Valmiki");
    Book book6("M3", "Ram Pande");

    motivationalShelf.push(book1);
    motivationalShelf.push(book2);
    motivationalShelf.push(book3);
    motivationalShelf.push(book4);
    motivationalShelf.push(book5);

    // This will cause overflow
    motivationalShelf.push(book6);

    // Display all books
    motivationalShelf.display();

    // Peek top book
    motivationalShelf.peek();

    // Pop two books
    motivationalShelf.pop();
    motivationalShelf.pop();

    // Display again
    motivationalShelf.display();

    return 0;
}
```

 

# ‚úÖ **What Students Learn From This Extended Program**

### ‚úî 1. Stack Behavior (LIFO)

The last book added is the first one removed.

### ‚úî 2. Error Handling

* Overflow when the shelf reaches its maximum limit.
* Underflow when trying to pop from an empty shelf.

### ‚úî 3. Object-Oriented Design

Use of classes, constructors, member functions, and array composition.

### ‚úî 4. Useful Operations

* `push()`
* `pop()`
* `peek()`
* `display()`
 

# üìò **The ‚ÄúApplied Bookshelf‚Äù Data Structure**

**Imagine I am your mentor**, and today we aren‚Äôt just learning *Data Structures*‚Ä¶
We are going to **enter a library**, meet a librarian, and understand how a **Stack** works‚Äî
not with boring memory diagrams, but with **real books**.
 

## üßë‚Äçüè´ **Scene 1: The Library and the Shelf**

I ask the students:

> ‚ÄúYou all have seen a bookshelf at home, right?
> Now imagine a special shelf in the library that has a rule:
>
> üëâ *You can only add books on the TOP*
> üëâ *You can only remove books from the TOP*
>
> That‚Äôs it.
>
> This is called a **Stack** ‚Äî Last In, First Out (LIFO).‚Äù

Then I show them the Shelf class.

  

## üìö **Scene 2: The Books Arrive**

Now, five new books arrive at the library:

* "You Can Win" ‚Äî Shiv Khera
* "Ignited Minds" ‚Äî APJ Kalam
* "The Monk Who Sold His Ferrari" ‚Äî Robin Sharma
* "Mahabharat" ‚Äî Vyas
* "Ramayan" ‚Äî Valmiki

And I tell students:

> ‚ÄúOur shelf can hold only **5 books**.
> If we try to put the 6th book, the shelf shouts:
>
> ‚ùå *Overflow! I am full!*‚Äù

This is exactly the concept of **stack overflow**.

 

## ü™ú **Scene 3: Adding Books ‚Äî The PUSH Operation**

Line by line, we push books:

```cpp
theShelf.push(book1);
theShelf.push(book2);
theShelf.push(book3);
theShelf.push(book4);
theShelf.push(book5);
```

I explain:

> ‚ÄúEvery time you call `push()`, the librarian climbs a step,
> places the book at the top, and updates the `top` index.‚Äù
>
> ‚úî Book1 goes to position 0
> ‚úî Book2 ‚Üí position 1
> ‚úî ‚Ä¶ and so on
>
> After book5, the top = 4, which is the last spot.

Now we ask the shelf:

```cpp
theShelf.display();
```

> ‚ÄúThis shows all books from *top to bottom*,
> just like seeing your actual bookstack.‚Äù
 

## üîª **Scene 4: Removing Books ‚Äî The POP Operation**

Now I tell the class:

> ‚ÄúImagine the librarian removing books for cleaning.
>
> But again ‚Äî only from the TOP!‚Äù

So we do:

```cpp
theShelf.pop();
theShelf.pop();
theShelf.pop();
theShelf.pop();
theShelf.pop();
```

Students understand:

* First `pop()` removes Ramayan
* Next removes Mahabharat
* And so on‚Ä¶

Now the shelf becomes **empty**.

But our code does one more:

```cpp
theShelf.pop();  /// underflow
```

And I tell the students:

> ‚ÄúIf the librarian tries to remove a book from an empty shelf,
> the shelf screams again:
>
> ‚ùå *Underflow! There is no book left to remove!*‚Äù

This is the concept of **stack underflow**.

---

## üìñ **Scene 5: Final Display**

Then we print:

```cpp
cout<<"|n\n After first Pop \n";
theShelf.display();
```

Since all books were popped, the shelf politely says:

> ‚ÄúNo books to display.‚Äù

 

# üéØ **Learning Outcome (What Students Now Understand)**

By the end of this story, students understand:

### ‚úî What a stack really is

### ‚úî Why it is LIFO (Last In, First Out)

### ‚úî How PUSH and POP work

### ‚úî What overflow and underflow mean

### ‚úî How objects (Books) can be stored using a stack

### ‚úî How Data Structures help build real applications

It‚Äôs no longer theory‚Ä¶
It‚Äôs now a **real-life, relatable learning experience**.
 